{"version":3,"sources":["../src/cli.ts","../package.json","../src/generator.ts","../src/utils.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport { resolve } from 'node:path';\nimport { Command } from 'commander';\nimport { version } from '../package.json';\nimport { generateCollection } from './generator';\n\nconst program = new Command();\n\nprogram\n\t.name('express-to-postman')\n\t.description('Generate a Postman Collection from an Express v5 app')\n\t.version(version)\n\t.showHelpAfterError()\n\t.requiredOption(\n\t\t'-i, --input <path>',\n\t\t'Path to your Express app entry file (JS or TS)',\n\t)\n\t.option(\n\t\t'-o, --output <path>',\n\t\t'Output path for collection JSON',\n\t\t'postman.collection.json',\n\t)\n\t.option('-v, --verbose', 'Enable verbose logging', false);\n\nif (process.argv.length <= 2) {\n\tprogram.outputHelp();\n\tprocess.exit(0);\n}\n\nprogram.exitOverride((err) => {\n\tconsole.error(err.message);\n\tprogram.outputHelp();\n\tprocess.exit(1);\n});\n\nprogram.parse(process.argv);\n\nconst opts = program.opts();\nconst inputPath = resolve(process.cwd(), opts.input);\nconst outputPath = resolve(process.cwd(), opts.output);\n\nif (opts.verbose) {\n\tconsole.log(`Loading app from: ${inputPath}`);\n}\n\ngenerateCollection(inputPath, outputPath, opts.verbose)\n\t.then(() => {\n\t\tconsole.log(`✅ Postman collection written to ${outputPath}`);\n\t})\n\t.catch((err: unknown) => {\n\t\tconsole.error('❌ Error generating collection:', err);\n\t\tprocess.exit(1);\n\t});\n","{\n\t\"name\": \"express-to-postman\",\n\t\"version\": \"1.1.3\",\n\t\"type\": \"module\",\n\t\"bin\": {\n\t\t\"express-to-postman\": \"dist/cli.js\"\n\t},\n\t\"repository\": {\n\t\t\"url\": \"https://github.com/Silent-Watcher/express-to-postman\"\n\t},\n\t\"keywords\": [\n\t\t\"express\",\n\t\t\"postman\",\n\t\t\"cli\",\n\t\t\"collection\",\n\t\t\"generator\"\n\t],\n\t\"imports\": {\n\t\t\"#app/*\": {\n\t\t\t\"my-package-dev\": \"src/*\",\n\t\t\t\"default\": \"./dist/*\"\n\t\t}\n\t},\n\t\"author\": \"Ali nazari backendwithali@gmail.com\",\n\t\"license\": \"MIT\",\n\t\"description\": \"CLI tool to read an Express.js project and generate a Postman collection JSON\",\n\t\"scripts\": {\n\t\t\"tsc\": \"tsc\",\n\t\t\"dev\": \"tsx --watch src/*.ts\",\n\t\t\"prebuild\": \"npm run tsc && npm run clean\",\n\t\t\"build\": \"tsup\",\n\t\t\"prestart\": \"npm run build\",\n\t\t\"start\": \"node dist/index.js\",\n\t\t\"test\": \"vitest run --coverage\",\n\t\t\"test:watch\": \"vitest dev\",\n\t\t\"prelint\": \"biome format --write ./src/*.ts ./tests/*.ts\",\n\t\t\"lint\": \"biome lint ./src/*.ts ./tests/*.ts\",\n\t\t\"check\": \"biome check --write ./src/*.ts ./tests/*.ts\",\n\t\t\"prepare\": \"husky\",\n\t\t\"commit\": \"cz\",\n\t\t\"clean\": \"del-cli dist/ coverage/ *.log\",\n\t\t\"prepublishOnly\": \"npm run test && npm run clean && npm run build\"\n\t},\n\t\"devDependencies\": {\n\t\t\"@biomejs/biome\": \"^1.9.4\",\n\t\t\"@types/express\": \"^5.0.3\",\n\t\t\"@types/mock-require\": \"^3.0.0\",\n\t\t\"@types/node\": \"^22.13.10\",\n\t\t\"@vitest/coverage-v8\": \"^3.0.9\",\n\t\t\"cz-conventional-changelog\": \"^3.3.0\",\n\t\t\"del-cli\": \"^6.0.0\",\n\t\t\"express\": \"^5.1.0\",\n\t\t\"husky\": \"^9.1.7\",\n\t\t\"lint-staged\": \"^16.1.0\",\n\t\t\"mock-require\": \"^3.0.3\",\n\t\t\"tsup\": \"^8.4.0\",\n\t\t\"tsx\": \"^4.19.3\",\n\t\t\"typescript\": \"^5.8.2\",\n\t\t\"vitest\": \"^3.0.9\"\n\t},\n\t\"peerDependencies\": {\n\t\t\"express\": \"^5.1.0\"\n\t},\n\t\"config\": {\n\t\t\"commitizen\": {\n\t\t\t\"path\": \"./node_modules/cz-conventional-changelog\"\n\t\t}\n\t},\n\t\"dependencies\": {\n\t\t\"commander\": \"^14.0.0\",\n\t\t\"esbuild\": \"^0.25.5\"\n\t}\n}\n","import { readFile, unlink, writeFile } from 'node:fs/promises';\nimport { basename, dirname, join } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { build } from 'esbuild';\nimport type { Application } from 'express';\nimport type { Collection, Item, ItemGroup } from './types';\nimport { extractRoutes, findProjectRoot } from './utils';\n\nexport async function loadApp(entryPath: string): Promise<unknown> {\n\tconst entryDir = dirname(entryPath);\n\n\tconst outFile = join(\n\t\tentryDir,\n\t\t`${basename(entryPath, '.ts')}-${Date.now()}.js`,\n\t);\n\n\tconst projectRoot = (await findProjectRoot(entryDir)) || entryDir;\n\tconst pkgJsonPath = join(projectRoot, 'package.json');\n\tlet deps: string[] = [];\n\ttry {\n\t\tconst pkg = JSON.parse(await readFile(pkgJsonPath, 'utf-8'));\n\t\tdeps = Object.keys(pkg.dependencies || {});\n\t} catch {\n\t\t// no package.json, or it’s unreadable — fall back to zero deps\n\t}\n\n\tawait build({\n\t\tentryPoints: [entryPath],\n\t\toutfile: outFile,\n\t\tbundle: true,\n\t\tformat: 'esm',\n\t\tplatform: 'node',\n\t\texternal: [...deps],\n\t});\n\n\tconst mod = await import(pathToFileURL(outFile).href);\n\tawait unlink(outFile);\n\treturn mod;\n}\n\nexport async function generateCollection(\n\tentryPath: string,\n\toutputPath: string,\n\tverbose: boolean,\n): Promise<void> {\n\tconst mod = (await loadApp(entryPath)) as { app?: unknown };\n\tconst app = mod.app;\n\tif (!app) {\n\t\tthrow new Error(`No named export \"app\" found in ${entryPath}`);\n\t}\n\n\tconst collection: Collection = {\n\t\tinfo: {\n\t\t\tname: entryPath.split(/[\\\\/]/).pop() || 'Express App',\n\t\t\tschema: 'https://schema.getpostman.com/json/collection/v2.1.0/collection.json',\n\t\t},\n\t\titem: [],\n\t};\n\n\tconst groups: Record<string, ItemGroup> = {};\n\n\tconsole.log(\n\t\t' extractRoutes(app as Application): ',\n\t\textractRoutes(app as Application),\n\t);\n\tfor (const { method, path } of extractRoutes(app as Application)) {\n\t\tconst segments = path.split('/').filter(Boolean);\n\t\tconst groupName = segments[0] || '/';\n\t\tif (!groups[groupName]) {\n\t\t\tgroups[groupName] = { name: groupName, item: [] };\n\t\t}\n\n\t\tconst item: Item = {\n\t\t\tname: `${method} ${path}`,\n\t\t\trequest: {\n\t\t\t\tmethod,\n\t\t\t\theader: [],\n\t\t\t\turl: {\n\t\t\t\t\traw: `{{baseUrl}}${path}`,\n\t\t\t\t\thost: ['{{baseUrl}}'],\n\t\t\t\t\tpath: segments,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tgroups[groupName].item.push(item);\n\t}\n\n\tfor (const key of Object.keys(groups)) {\n\t\tcollection.item.push(groups[key] as ItemGroup);\n\t}\n\n\tif (verbose) {\n\t\tconsole.log(JSON.stringify(collection, null, 2));\n\t}\n\n\tawait writeFile(outputPath, JSON.stringify(collection, null, 2), 'utf-8');\n}\n","import { access } from 'node:fs/promises';\nimport { dirname, join } from 'node:path';\nimport type { Application } from 'express';\n\nexport interface ExpressLayer {\n\troute?: {\n\t\tpath: string;\n\t\tmethods: Record<string, boolean>;\n\t};\n\tname: string;\n\thandle?: {\n\t\tstack?: ExpressLayer[];\n\t};\n\tregexp?: RegExp;\n}\n\nexport interface RouteInfo {\n\tmethod: string;\n\tpath: string;\n}\n\nexport function* extractRoutes(app: Application): Generator<RouteInfo> {\n\tconst routerStack =\n\t\t(app as Application)._router?.stack ??\n\t\t(app as Application).router?.stack;\n\n\tif (!routerStack || !Array.isArray(routerStack)) return;\n\n\tfor (const layer of routerStack as ExpressLayer[]) {\n\t\tif (!layer) continue;\n\n\t\tif (layer.route?.path && layer.route.methods) {\n\t\t\tfor (const method of Object.keys(layer.route.methods)) {\n\t\t\t\tyield { method: method.toUpperCase(), path: layer.route.path };\n\t\t\t}\n\t\t} else if (\n\t\t\tlayer.name === 'router' &&\n\t\t\tlayer.handle?.stack &&\n\t\t\tArray.isArray(layer.handle.stack)\n\t\t) {\n\t\t\tconst prefix =\n\t\t\t\tlayer.regexp?.source\n\t\t\t\t\t?.replace('\\\\/?(?=\\\\/|$)', '')\n\t\t\t\t\t.replace('^', '')\n\t\t\t\t\t.replace('$', '') || '';\n\n\t\t\tfor (const nested of layer.handle.stack) {\n\t\t\t\tif (nested?.route?.path && nested.route.methods) {\n\t\t\t\t\tfor (const method of Object.keys(nested.route.methods)) {\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\tmethod: method.toUpperCase(),\n\t\t\t\t\t\t\tpath: prefix + nested.route.path,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport async function findProjectRoot(\n\tstartDir: string,\n): Promise<string | null> {\n\tlet dir = startDir;\n\twhile (true) {\n\t\ttry {\n\t\t\tconst pkgPath = join(dir, 'package.json');\n\t\t\tawait access(pkgPath);\n\t\t\treturn dir;\n\t\t} catch {\n\t\t\tconst parent = dirname(dir);\n\t\t\tif (parent === dir) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tdir = parent;\n\t\t}\n\t}\n}\n"],"mappings":"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","names":["resolve","Command","version","readFile","unlink","writeFile","basename","dirname","join","pathToFileURL","build","access","dirname","join","extractRoutes","app","routerStack","layer","method","prefix","nested","findProjectRoot","startDir","dir","pkgPath","parent","loadApp","entryPath","entryDir","dirname","outFile","join","basename","projectRoot","findProjectRoot","pkgJsonPath","deps","pkg","readFile","build","mod","pathToFileURL","unlink","generateCollection","outputPath","verbose","app","collection","groups","extractRoutes","method","path","segments","groupName","item","key","writeFile","program","Command","version","err","opts","inputPath","resolve","outputPath","generateCollection"]}