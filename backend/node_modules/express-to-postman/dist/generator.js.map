{"version":3,"sources":["../src/generator.ts","../src/utils.ts"],"sourcesContent":["import { readFile, unlink, writeFile } from 'node:fs/promises';\nimport { basename, dirname, join } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { build } from 'esbuild';\nimport type { Application } from 'express';\nimport type { Collection, Item, ItemGroup } from './types';\nimport { extractRoutes, findProjectRoot } from './utils';\n\nexport async function loadApp(entryPath: string): Promise<unknown> {\n\tconst entryDir = dirname(entryPath);\n\n\tconst outFile = join(\n\t\tentryDir,\n\t\t`${basename(entryPath, '.ts')}-${Date.now()}.js`,\n\t);\n\n\tconst projectRoot = (await findProjectRoot(entryDir)) || entryDir;\n\tconst pkgJsonPath = join(projectRoot, 'package.json');\n\tlet deps: string[] = [];\n\ttry {\n\t\tconst pkg = JSON.parse(await readFile(pkgJsonPath, 'utf-8'));\n\t\tdeps = Object.keys(pkg.dependencies || {});\n\t} catch {\n\t\t// no package.json, or it’s unreadable — fall back to zero deps\n\t}\n\n\tawait build({\n\t\tentryPoints: [entryPath],\n\t\toutfile: outFile,\n\t\tbundle: true,\n\t\tformat: 'esm',\n\t\tplatform: 'node',\n\t\texternal: [...deps],\n\t});\n\n\tconst mod = await import(pathToFileURL(outFile).href);\n\tawait unlink(outFile);\n\treturn mod;\n}\n\nexport async function generateCollection(\n\tentryPath: string,\n\toutputPath: string,\n\tverbose: boolean,\n): Promise<void> {\n\tconst mod = (await loadApp(entryPath)) as { app?: unknown };\n\tconst app = mod.app;\n\tif (!app) {\n\t\tthrow new Error(`No named export \"app\" found in ${entryPath}`);\n\t}\n\n\tconst collection: Collection = {\n\t\tinfo: {\n\t\t\tname: entryPath.split(/[\\\\/]/).pop() || 'Express App',\n\t\t\tschema: 'https://schema.getpostman.com/json/collection/v2.1.0/collection.json',\n\t\t},\n\t\titem: [],\n\t};\n\n\tconst groups: Record<string, ItemGroup> = {};\n\n\tconsole.log(\n\t\t' extractRoutes(app as Application): ',\n\t\textractRoutes(app as Application),\n\t);\n\tfor (const { method, path } of extractRoutes(app as Application)) {\n\t\tconst segments = path.split('/').filter(Boolean);\n\t\tconst groupName = segments[0] || '/';\n\t\tif (!groups[groupName]) {\n\t\t\tgroups[groupName] = { name: groupName, item: [] };\n\t\t}\n\n\t\tconst item: Item = {\n\t\t\tname: `${method} ${path}`,\n\t\t\trequest: {\n\t\t\t\tmethod,\n\t\t\t\theader: [],\n\t\t\t\turl: {\n\t\t\t\t\traw: `{{baseUrl}}${path}`,\n\t\t\t\t\thost: ['{{baseUrl}}'],\n\t\t\t\t\tpath: segments,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tgroups[groupName].item.push(item);\n\t}\n\n\tfor (const key of Object.keys(groups)) {\n\t\tcollection.item.push(groups[key] as ItemGroup);\n\t}\n\n\tif (verbose) {\n\t\tconsole.log(JSON.stringify(collection, null, 2));\n\t}\n\n\tawait writeFile(outputPath, JSON.stringify(collection, null, 2), 'utf-8');\n}\n","import { access } from 'node:fs/promises';\nimport { dirname, join } from 'node:path';\nimport type { Application } from 'express';\n\nexport interface ExpressLayer {\n\troute?: {\n\t\tpath: string;\n\t\tmethods: Record<string, boolean>;\n\t};\n\tname: string;\n\thandle?: {\n\t\tstack?: ExpressLayer[];\n\t};\n\tregexp?: RegExp;\n}\n\nexport interface RouteInfo {\n\tmethod: string;\n\tpath: string;\n}\n\nexport function* extractRoutes(app: Application): Generator<RouteInfo> {\n\tconst routerStack =\n\t\t(app as Application)._router?.stack ??\n\t\t(app as Application).router?.stack;\n\n\tif (!routerStack || !Array.isArray(routerStack)) return;\n\n\tfor (const layer of routerStack as ExpressLayer[]) {\n\t\tif (!layer) continue;\n\n\t\tif (layer.route?.path && layer.route.methods) {\n\t\t\tfor (const method of Object.keys(layer.route.methods)) {\n\t\t\t\tyield { method: method.toUpperCase(), path: layer.route.path };\n\t\t\t}\n\t\t} else if (\n\t\t\tlayer.name === 'router' &&\n\t\t\tlayer.handle?.stack &&\n\t\t\tArray.isArray(layer.handle.stack)\n\t\t) {\n\t\t\tconst prefix =\n\t\t\t\tlayer.regexp?.source\n\t\t\t\t\t?.replace('\\\\/?(?=\\\\/|$)', '')\n\t\t\t\t\t.replace('^', '')\n\t\t\t\t\t.replace('$', '') || '';\n\n\t\t\tfor (const nested of layer.handle.stack) {\n\t\t\t\tif (nested?.route?.path && nested.route.methods) {\n\t\t\t\t\tfor (const method of Object.keys(nested.route.methods)) {\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\tmethod: method.toUpperCase(),\n\t\t\t\t\t\t\tpath: prefix + nested.route.path,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport async function findProjectRoot(\n\tstartDir: string,\n): Promise<string | null> {\n\tlet dir = startDir;\n\twhile (true) {\n\t\ttry {\n\t\t\tconst pkgPath = join(dir, 'package.json');\n\t\t\tawait access(pkgPath);\n\t\t\treturn dir;\n\t\t} catch {\n\t\t\tconst parent = dirname(dir);\n\t\t\tif (parent === dir) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tdir = parent;\n\t\t}\n\t}\n}\n"],"mappings":"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","names":["readFile","unlink","writeFile","basename","dirname","join","pathToFileURL","build","access","dirname","join","extractRoutes","app","routerStack","layer","method","prefix","nested","findProjectRoot","startDir","dir","pkgPath","parent","loadApp","entryPath","entryDir","dirname","outFile","join","basename","projectRoot","findProjectRoot","pkgJsonPath","deps","pkg","readFile","build","mod","pathToFileURL","unlink","generateCollection","outputPath","verbose","app","collection","groups","extractRoutes","method","path","segments","groupName","item","key","writeFile"]}